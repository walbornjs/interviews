Начало 1:22:50 (1:23:46)
Конец 1:32:50

## Задание
Отрефакторить код. Какие проблемы ты видишь?
```jsx
const DataList = ({ queryParameter }) => {
  const [data, setData] = useState()

  useEffect(async () => {
    setData(await fetchDataFromServer(queryParameter))
  })

  return (
    <div>
      {data.map((dataElement) => <div>{dataElement}</div>)}
    </div>
  )
}

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
```

Вот отрефакторенный код с исправлением основных проблем:

```jsx
const DataList = ({ queryParameter }) => {
  const [data, setData] = useState([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState(null)

  useEffect(() => {
    let isMounted = true // Флаг для отслеживания монтирования компонента
    
    const fetchData = async () => {
      try {
        setIsLoading(true)
        const result = await fetchDataFromServer(queryParameter)
        if (isMounted) {
          setData(result)
          setError(null)
        }
      } catch (err) {
        if (isMounted) {
          setError(err.message)
          setData([])
        }
      } finally {
        if (isMounted) setIsLoading(false)
      }
    }

    fetchData()

    return () => {
      isMounted = false // Очистка при размонтировании
    }
  }, [queryParameter]) // Зависимость от queryParameter

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (error) {
    return <div>Error: {error}</div>
  }

  return (
    <div>
      {data.map((dataElement, index) => (
        <div key={`element-${index}`}>{dataElement}</div>
      ))}
    </div>
  )
}

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(<App />)
```

### Исправленные проблемы:

1. **Асинхронный useEffect**: 
   - Убран async из колбэка useEffect
   - Создана отдельная асинхронная функция внутри эффекта
   - Добавлена отмена запросов через флаг isMounted

2. **Бесконечные ререндеры**:
   - Добавлен массив зависимостей [queryParameter]

3. **Обработка начального состояния**:
   - Начальное значение data установлено как []

4. **Обработка ошибок и состояний загрузки**:
   - Добавлены состояния isLoading и error
   - Реализована обработка ошибок try/catch

5. **Ключи для списка**:
   - Добавлен key prop для элементов списка

6. **Race conditions**:
   - Добавлен флаг isMounted для предотвращения обновления состояния после размонтирования компонента

7. **Безопасное обновление состояния**:
   - Все setState обернуты в проверку isMounted

### Дополнительные улучшения, которые можно сделать:
- Добавить пропсы для кастомизации сообщений загрузки/ошибки
- Реализовать повторный запрос при ошибке
- Добавить прерывание fetch-запроса с помощью AbortController
- Вынести логику получения данных в кастомный хук
- Добавить пропы для кастомизации рендеринга элементов
- Реализовать виртуализацию списка при большом количестве элементов
- Добавить обработку пустого состояния данных


## Можешь рассказать про стадии жизненного цикла компонента, как на них подписываться?
1. Mounting - создание и добавление компонента в DOM
`useEffect` с пустым массивом зависимостей `[]`
2. Updating - изменение компонента в ответ на новые свойства (props) или состояние (state)
`useEffect` с массивом зависимостей `[something]` или вообще без него
3. Unmounting - удаление компонента из DOM
Функция, которая возвращается из `useEffect`
4. Error Handling - управление ошибками, возникающими в компоненте или его потомках
В функциональных компонентах обработка ошибок недоступна напрямую, но можно использовать обёртки, такие как Error Boundaries, реализованные в классовых компонентах

## Какие знаешь хуки?


- Управления состоянием (useState, useReducer, useContext).
- Оптимизации производительности (useMemo, useCallback).
- Работы с DOM и побочными эффектами (useEffect, useLayoutEffect, useRef).
- Улучшения UX и отладки (useTransition, useDeferredValue, useDebugValue).
- Интеграции с внешними системами и доступности (useSyncExternalStore, useId).


1. useState: управляет локальным состоянием.
2. useEffect: обрабатывает побочные эффекты (например, запросы к API).
3. useContext: дает доступ к контексту для передачи данных
4. useMemo - кэширует результат функции
5. useCallback - кэширует саму функцию, чтоб не пересоздавть ее при каждом рендере
6. useRef - возвращает мутабельный объект, который сохраняет своё значение между рендерами.
7. useReducer - альтернатива useState, если состояние сложное
8. useImperativeHandle - позволяет настроить ссылку (ref), передаваемую родительскому компоненту, чтобы контролировать, какие методы или свойства будут доступны
9. useLayoutEffect - похож на useEffect, но выполняется синхронно после всех мутаций DOM, до перерисовки экрана. 
10. useDebugValue - отображает пользовательские метки в инструментах разработчика React. Полезен для отладки пользовательских хуков

### Новые и экспериментальные хуки
11. useDeferredValue - откладывает обновление значения, чтобы избежать блокировки интерфейса при рендеринге больших данных или сложных компонентов
12. useTransition - помогает управлять состоянием во время переходов, помечая обновления как "переходы" для сохранения отзывчивости UI.
13. useId - генерирует уникальный идентификатор, который можно использовать для связывания элементов, например, в формах или для доступности
14. useSyncExternalStore - позволяет подписываться на внешнее хранилище (например, Redux) и синхронизировать его с состоянием компонента.
15. useInsertionEffect - экспериментальный хук, выполняющийся до внесения изменений в DOM. Предназначен для вставки стилей или других ресурсов (в основном для библиотек вроде CSS-in-JS).

16. use - не совсем хук
Появился в React 19. Предназначен для упрощения работы с асинхронными операциями и контекстом. Вот ключевые особенности:
- Для асинхронных данных (аналог `await` в компонентах)
   - Позволяет использовать промисы напрямую в компонентах без `useEffect`.
   - Интегрируется с **Suspense**: автоматически приостанавливает рендеринг, пока данные загружаются.
   - Пример:
     ```jsx
     function UserProfile({ userId }) {
       const user = use(fetchUser(userId)); // fetchUser возвращает промис
       return <div>{user.name}</div>;
     }
     ```
- Для контекста (альтернатива `useContext`)
   - Может читать значение контекста, но с гибкостью (например, внутри условий).
   - Пример:
     ```jsx
     const theme = use(ThemeContext)
     ```

- Ключевые отличия от других хуков
   - Можно вызывать в условиях и циклах (в отличие от `useEffect` или `useState`).
   - Работает с промисами: резолвит данные "на лету".
   - Требует `<Suspense>`: для обработки загрузки и ошибок (через Error Boundaries)
   - Убирает "чехарду" состояний (`isLoading`, `error`).
   - Работает только внутри компонентов или кастомных хуков.
   - Не заменяет `useState`/`useEffect` для интерактивности (например, обновления по клику).
